<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emoji Flux ‚Äî Online & Big Wins</title>
  <style>
    :root{
      --bg1:#071029; --bg2:#0f1724; --card:rgba(255,255,255,0.02);
      --accent:#ffd166; --muted:#98a8c7;
      --slot-size:88px; --slot-gap:12px;
      --font-sans: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      --flash-color: rgba(255,240,200,0.92);
    }
    body{margin:0;font-family:var(--font-sans);background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--muted);min-height:100vh}
    header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px}
    .brand{font-weight:800;color:var(--accent);letter-spacing:.6px}
    .controls{display:flex;gap:10px;align-items:center}
    select,input[type="text"],input[type="number"]{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{padding:8px 12px;border-radius:10px;border:none;background:linear-gradient(90deg,var(--accent),#ffb86b);color:#08101a;font-weight:700;cursor:pointer}
    main{display:flex;gap:18px;padding:18px;align-items:flex-start}
    .field{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center}
    .panel{width:100%;max-width:980px;padding:18px;border-radius:12px;background:linear-gradient(180deg,var(--card), rgba(255,255,255,0.01));box-shadow:0 12px 36px rgba(2,6,23,0.45);display:flex;flex-direction:column;align-items:center;gap:12px}
    .grid{display:grid;grid-template-columns:repeat(3, var(--slot-size));grid-gap:var(--slot-gap);padding:10px}
    .slot{width:var(--slot-size);height:var(--slot-size);border-radius:14px;display:flex;align-items:center;justify-content:center;font-size:42px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 8px 20px rgba(0,0,0,0.35);transition:transform .18s, box-shadow .18s, filter .18s}
    .slot.enter{opacity:0; transform:translateY(-30px) scale(.95); animation:slot-in .46s cubic-bezier(.2,.9,.3,1) var(--delay) both}
    @keyframes slot-in{0%{opacity:0;transform:translateY(-30px) scale(.95)}60%{transform:translateY(6px) scale(1.06)}100%{opacity:1;transform:translateY(0) scale(1)}}
    .slot.win{box-shadow:0 18px 56px rgba(255,200,90,0.14); transform:scale(1.06); filter:brightness(1.12)}
    .top-controls{display:flex;gap:12px;align-items:center;width:100%;justify-content:space-between}
    .score{font-weight:700;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02)}
    .aside-section{background:var(--card);padding:12px;border-radius:10px;margin-bottom:12px}
    .bigwins-list{max-height:260px;overflow:auto;padding:8px 6px}
    .bigwin-item{padding:8px;border-bottom:1px solid rgba(255,255,255,0.02);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .bigwin-left{display:flex;gap:8px;align-items:center}
    .bigwin-emoji{font-size:18px}
    .bigwin-nick{font-weight:700}
    .bigwin-amount{color:var(--accent)}
    .online-counter{font-weight:700;color:var(--accent-2)}
    .flash{position:fixed;inset:0;pointer-events:none;z-index:90;background:var(--flash-color);opacity:0;transition:opacity .18s}
    canvas#confetti{position:fixed;left:0;top:0;pointer-events:none;z-index:80}
    @media (max-width:980px){main{flex-direction:column} aside{width:100%}}
  </style>
</head>
<body>
  <div class="flash" id="flash"></div>
  <canvas id="confetti"></canvas>

  <header>
    <div class="brand">Emoji Flux ‚Äî Wild Grid</div>
    <div class="controls">
      <input id="nick" type="text" placeholder="NewPlayer" maxlength="20" />
      <select id="dynSelect"><option value="low">–î–∏–Ω–∞–º–∏—á–Ω–æ—Å—Ç—å: –ù–∏–∑–∫–∞—è</option><option value="normal">–î–∏–Ω–∞–º–∏—á–Ω–æ—Å—Ç—å: –û–±—ã—á–Ω–∞—è</option><option value="high">–î–∏–Ω–∞–º–∏—á–Ω–æ—Å—Ç—å: –í—ã—Å–æ–∫–∞—è</option></select>
      <button id="startBtn">–°—Ç–∞—Ä—Ç</button>
    </div>
  </header>

  <main>
    <section class="field">
      <div class="panel">
        <div class="top-controls">
          <div style="display:flex;gap:10px;align-items:center">
            <label>–°—Ç–∞–≤–∫–∞</label>
            <input id="betInput" type="number" min="1" step="1" value="20" style="width:120px" />
            <button id="minBet">–ú–∏–Ω</button>
            <button id="halfBet">1/2</button>
            <button id="maxBet">–ú–∞–∫—Å</button>
          </div>
          <div class="score" id="scoreText">–ù–∞–∂–º–∏—Ç–µ ¬´–°—Ç–∞—Ä—Ç¬ª</div>
        </div>

        <div style="position:relative;padding:8px">
          <div class="grid" id="grid"></div>
        </div>

        <div style="display:flex;gap:12px">
          <button id="spinBtn">–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ç–æ–∫</button>
          <button id="resetBtn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)">–°–±—Ä–æ—Å</button>
        </div>
      </div>
    </section>

    <aside style="width:360px">
      <div class="aside-section">
        –û–Ω–ª–∞–π–Ω: <span id="online" class="online-counter">‚Äî</span>
        <div style="margin-top:8px">–ì–ª–æ–±. —É–¥–∞—á–∞: <span id="luck">1.00</span></div>
      </div>

      <div class="aside-section">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">–ë–æ–ª—å—à–∏–µ –≤—ã–∏–≥—Ä—ã—à–∏</div>
          <button id="clearBigWins" style="background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted)">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
        <div class="bigwins-list" id="bigWinsList">
          <!-- items -->
        </div>
      </div>

      <div class="aside-section">
        <div>–ë–∞–ª–∞–Ω—Å: <span id="balanceText">‚Äî</span></div>
        <div style="margin-top:8px">–ü–æ—Å–ª–µ–¥–Ω–∏–π –∫—ç—à–±–µ–∫: <span id="lastCashback">‚Äî</span></div>
      </div>
    </aside>
  </main>

  <script>
  // --- CONFIG: If you want real online counter and shared big wins, paste your Firebase config below ---
  const firebaseConfig = {
    apiKey: "YOUR_KEY",
    authDomain: "YOUR_PROJECT.firebaseapp.com",
    databaseURL: "https://YOUR_PROJECT.firebaseio.com",
    projectId: "YOUR_PROJECT_ID",
  };
  // --------------------------------------------------------------------------------------------

  // Game config
  const EMOJI_POOL = ['üî•','‚ö°Ô∏è','üíß','üçÄ','üåü','üéØ','üçé','üíé','üåä','‚òÑÔ∏è','‚ú®','üéµ','üé≤'];
  const ROWS = 3, COLS = 3, SLOT_COUNT = ROWS * COLS;
  const STARTER_BONUS = 100;
  const START_BALANCE_DEFAULT = 100;
  const CASHBACK_RATE_PER_DAY = 0.10;
  const CASHBACK_INTERVAL_MS = 60 * 1000;
  const DYN_MULT = { low:0.6, normal:1.0, high:1.8 };
  const LINE_MULT = { 3:3.0, 2:0.6, 1:0.0 };

  // Big win criteria
  const BIG_WIN_NET_MIN = 100;      // net gain at least this
  const BIG_WIN_MULT_MIN = 4.0;     // or multiplier at least this

  // DOM
  const gridEl = document.getElementById('grid');
  const nickInput = document.getElementById('nick');
  const dynSelect = document.getElementById('dynSelect');
  const startBtn = document.getElementById('startBtn');
  const spinBtn = document.getElementById('spinBtn');
  const resetBtn = document.getElementById('resetBtn');
  const betInput = document.getElementById('betInput');
  const minBetBtn = document.getElementById('minBet');
  const halfBetBtn = document.getElementById('halfBet');
  const maxBetBtn = document.getElementById('maxBet');
  const scoreText = document.getElementById('scoreText');
  const balanceText = document.getElementById('balanceText');
  const lastCashbackEl = document.getElementById('lastCashback');
  const onlineEl = document.getElementById('online');
  const bigWinsListEl = document.getElementById('bigWinsList');
  const clearBigWinsBtn = document.getElementById('clearBigWins');
  const luckEl = document.getElementById('luck');
  const flashEl = document.getElementById('flash');
  const confettiCanvas = document.getElementById('confetti');

  // state
  let nick = localStorage.getItem('nick') || 'NewPlayer';
  nickInput.value = nick;
  let dyn = localStorage.getItem('dyn') || 'normal';
  dynSelect.value = dyn;

  // balance persisted robustly
  let balance;
  const storedBalance = localStorage.getItem('balance');
  if (storedBalance !== null) {
    const p = parseInt(storedBalance, 10);
    balance = Number.isNaN(p) ? START_BALANCE_DEFAULT : p;
  } else {
    balance = START_BALANCE_DEFAULT;
  }
  // starter bonus once
  if (!localStorage.getItem('starterClaimed')) {
    balance = (Number(balance) || 0) + STARTER_BONUS;
    localStorage.setItem('balance', String(balance));
    localStorage.setItem('starterClaimed', '1');
    // small welcome
    alert(`–ë–æ–Ω—É—Å: +${STARTER_BONUS} ‚ÇΩ`);
  }

  let vault = parseInt(localStorage.getItem('vault') || '0', 10) || 0;
  let lastAccrual = parseInt(localStorage.getItem('lastAccrual') || Date.now(), 10);
  let lastDailyRoll = parseInt(localStorage.getItem('lastDailyRoll') || '0', 10) || 0;

  updateBalanceUI();
  if (lastCashbackEl) lastCashbackEl.textContent = localStorage.getItem('lastCashbackCredit') || '‚Äî';

  // create grid
  function createGrid(){
    gridEl.innerHTML = '';
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.dataset.r = r;
        slot.dataset.c = c;
        gridEl.appendChild(slot);
      }
    }
  }
  createGrid();

  // confetti
  const Confetti = (() => {
    const c = confettiCanvas;
    const ctx = c.getContext('2d');
    let W=0,H=0, parts=[];
    function resize(){ W=c.width=innerWidth; H=c.height=innerHeight; }
    addEventListener('resize', resize); resize();
    function spawn(x,y,n,spread=120,power=14){
      for (let i=0;i<n;i++){
        parts.push({ x: x + (Math.random()-0.5)*spread, y: y + (Math.random()-0.5)*spread, vx:(Math.random()-0.5)*power, vy: -Math.random()*power - 2, r: Math.random()*10+4, col: ['#ffd166','#6ee7b7','#60a5fa','#f472b6','#fff59d','#b4f8c8'][Math.floor(Math.random()*6)], life:0, ttl:80 + Math.floor(Math.random()*120) });
      }
      if (!animating) loop();
    }
    let animating = false;
    function loop(){
      animating = true;
      ctx.clearRect(0,0,W,H);
      for (let i=parts.length-1;i>=0;i--){
        const p = parts[i];
        p.life++; p.vy += 0.35; p.x += p.vx; p.y += p.vy;
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.life*0.07);
        ctx.fillStyle = p.col; ctx.fillRect(-p.r/2,-p.r/2,p.r,p.r*0.6); ctx.restore();
        if (p.y > H + 50 || p.life > p.ttl) parts.splice(i,1);
      }
      if (parts.length>0) requestAnimationFrame(loop);
      else animating = false;
    }
    return { spawn };
  })();

  // lines
  function getLines(){
    const lines = [];
    for (let r=0;r<ROWS;r++) lines.push(Array.from({length:COLS}, (_,c)=>[r,c]));
    for (let c=0;c<COLS;c++) lines.push(Array.from({length:ROWS}, (_,r)=>[r,c]));
    lines.push([[0,0],[1,1],[2,2]]);
    lines.push([[0,2],[1,1],[2,0]]);
    return lines;
  }
  const LINES = getLines();

  // animate grid
  function animateGrid(arr, winCellsFlat=[]){
    const slots = Array.from(gridEl.children);
    slots.forEach((s,i)=>{
      s.className = 'slot enter';
      s.style.setProperty('--delay', `${(i%COLS)*0.05}s`);
      s.textContent = arr[i] || '‚ùî';
      s.addEventListener('animationend', function onEnd(){
        s.classList.remove('enter'); s.removeEventListener('animationend', onEnd);
        if (winCellsFlat.includes(i)){
          s.classList.add('win'); setTimeout(()=> s.classList.remove('win'), 900);
        }
      });
    });
  }

  // compute lines
  function computeLineScores(gridArr){
    const lineResults = [];
    for (const line of LINES){
      const values = line.map(([r,c]) => gridArr[r*COLS + c]);
      const freq = {}; values.forEach(v=> freq[v] = (freq[v]||0)+1);
      const bestCount = Math.max(...Object.values(freq));
      const bestEmoji = Object.keys(freq).find(k=>freq[k]===bestCount);
      lineResults.push({ values, bestCount, bestEmoji, cells: line });
    }
    return lineResults;
  }

  // RNG
  function getGlobalLuck(){ return parseFloat(luckEl.textContent) || 1.0; }
  function generateGrid(){
    const globalLuck = getGlobalLuck();
    let baseFavor = Math.min(0.28 * (globalLuck - 1), 0.5);
    const dmult = DYN_MULT[dyn] || 1.0;
    const favor = Math.min(baseFavor * dmult, 0.75);
    const res = [];
    for (let i=0;i<SLOT_COUNT;i++){
      if (i>0 && Math.random() < favor){
        if (Math.random() < 0.6) res.push(res[i-1]);
        else res.push(res[Math.floor(Math.random()*i)]);
      } else res.push(EMOJI_POOL[Math.floor(Math.random()*EMOJI_POOL.length)]);
    }
    return res;
  }

  // payouts
  function payoutFromLines(bet, lineResults){
    let totalMul = 0; let winningCellsFlat = [];
    for (const lr of lineResults){
      const c = lr.bestCount;
      if (LINE_MULT[c] && LINE_MULT[c] > 0){
        totalMul += LINE_MULT[c];
        lr.cells.forEach(([r,c2]) => winningCellsFlat.push(r*COLS + c2));
      }
    }
    totalMul = Math.min(totalMul, 12);
    const payout = Math.round(bet * totalMul);
    const net = payout - bet;
    return { payout, net, totalMul, winningCellsFlat: [...new Set(winningCellsFlat)] };
  }

  // visuals
  function triggerExplosion(x,y,intensity){
    if (flashEl) flashEl.style.opacity = '1';
    setTimeout(()=> { if (flashEl) flashEl.style.opacity = '0'; }, 200 + intensity*40);
    const panel = document.querySelector('.panel'); if (panel) panel.classList.add('shake');
    setTimeout(()=> { if (panel) panel.classList.remove('shake'); }, 700);
    Confetti.spawn(x,y, 80 + intensity*60, 220, 20 + intensity*6);
  }

  // balance helpers
  function updateBalanceUI(){ balanceText.textContent = `${balance} ‚ÇΩ`; try{ localStorage.setItem('balance', String(balance)); }catch{} }
  function updateVaultUI(){ vaultText.textContent = `${vault} ‚ÇΩ`; try{ localStorage.setItem('vault', String(vault)); }catch{} }

  // --- ONLINE + BIG WINS (Firebase if configured) ---
  let firebaseDb = null;
  let sessionId = null;

  function loadFirebaseIfConfigured(){
    if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_KEY") {
      // no firebase: use local simulation
      startSimulatedOnline();
      loadLocalBigWins();
      return Promise.resolve();
    }
    // load scripts dynamically
    return new Promise((resolve) => {
      const s1 = document.createElement('script');
      s1.src = "https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js";
      const s2 = document.createElement('script');
      s2.src = "https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js";
      s2.onload = () => {
        try {
          firebase.initializeApp(firebaseConfig);
          firebaseDb = firebase.database();
          // anonymous auth if available
          if (firebase.auth) {
            try { firebase.auth().signInAnonymously().catch(()=>{}); } catch(e){}
          }
          setupPresence();
          setupBigWinsListener();
        } catch(e){
          console.warn('Firebase init failed', e);
          startSimulatedOnline();
          loadLocalBigWins();
        } finally {
          resolve();
        }
      };
      document.head.appendChild(s1);
      document.head.appendChild(s2);
    });
  }

  // Presence implementation
  function setupPresence(){
    try {
      sessionId = 's_' + Math.random().toString(36).slice(2,9);
      const presRef = firebaseDb.ref('presence/' + sessionId);
      presRef.set({ nick: nickInput.value || 'NewPlayer', ts: Date.now() });
      presRef.onDisconnect().remove();
      const allRef = firebaseDb.ref('presence');
      allRef.on('value', snap => {
        const val = snap.val() || {};
        const count = Object.keys(val).length;
        onlineEl.textContent = count;
      });
    } catch(e){
      console.warn('presence failed', e);
      startSimulatedOnline();
    }
  }

  // Big wins listener: read last 50 entries
  function setupBigWinsListener(){
    try {
      const bwRef = firebaseDb.ref('bigWins').limitToLast(50);
      bwRef.on('value', snap => {
        const arr = [];
        snap.forEach(s => arr.push(s.val()));
        // sort descending by ts
        arr.sort((a,b)=> b.ts - a.ts);
        renderBigWins(arr);
      });
    } catch(e){
      console.warn('bigWins listener failed', e);
      loadLocalBigWins();
    }
  }

  // push big win to db if available otherwise to local
  function pushBigWin(entry){
    if (firebaseDb) {
      try {
        firebaseDb.ref('bigWins').push(entry).catch(()=>{});
        return;
      } catch(e){ /* fallback */ }
    }
    // fallback: save locally
    const existing = JSON.parse(localStorage.getItem('localBigWins') || '[]');
    existing.unshift(entry);
    localStorage.setItem('localBigWins', JSON.stringify(existing.slice(0,200)));
    renderBigWins(existing);
  }

  // render big wins UI
  function renderBigWins(list){
    // list: array of {nick, amount, multiplier, bet, payout, ts, emoji}
    bigWinsListEl.innerHTML = '';
    if (!list || list.length === 0) {
      bigWinsListEl.innerHTML = '<div style="padding:8px;color:var(--muted)">–ü–æ–∫–∞ –Ω–µ—Ç –±–æ–ª—å—à–∏—Ö –≤—ã–∏–≥—Ä—ã—à–µ–π</div>';
      return;
    }
    list.slice(0,50).forEach(item => {
      const li = document.createElement('div');
      li.className = 'bigwin-item';
      const left = document.createElement('div'); left.className = 'bigwin-left';
      const emoji = document.createElement('div'); emoji.className = 'bigwin-emoji'; emoji.textContent = item.emoji || 'üéâ';
      const info = document.createElement('div');
      const nickEl = document.createElement('div'); nickEl.className = 'bigwin-nick'; nickEl.textContent = item.nick || 'Player';
      const time = new Date(item.ts || Date.now());
      const timeStr = time.toLocaleString();
      const meta = document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='var(--muted)'; meta.textContent = `${timeStr} ‚Ä¢ x${(item.multiplier||0).toFixed(2)}`;
      info.appendChild(nickEl); info.appendChild(meta);
      left.appendChild(emoji); left.appendChild(info);
      const right = document.createElement('div'); right.className = 'bigwin-amount'; right.textContent = `+${item.amount} ‚ÇΩ`;
      li.appendChild(left); li.appendChild(right);
      bigWinsListEl.appendChild(li);
    });
  }

  // local load big wins fallback
  function loadLocalBigWins(){
    const arr = JSON.parse(localStorage.getItem('localBigWins') || '[]');
    renderBigWins(arr);
  }

  // simulated online if no firebase
  let simOnlineInterval = null;
  function startSimulatedOnline(){
    let count = Math.max(1, Math.floor(Math.random()*12) + 2);
    onlineEl.textContent = count;
    simOnlineInterval = setInterval(()=>{
      // small random walk
      count += (Math.random() < 0.5 ? -1 : 1) * (Math.random() < 0.7 ? 1 : 2);
      if (count < 1) count = 1;
      onlineEl.textContent = count;
    }, 3500);
  }

  // Clear big wins (local only)
  clearBigWinsBtn.addEventListener('click', ()=>{
    if (firebaseDb) {
      // trying to clear remote big wins is dangerous; warn user
      if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã? –≠—Ç–æ –æ—á–∏—Å—Ç–∏—Ç —Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫. –î–ª—è –æ—á–∏—Å—Ç–∫–∏ —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–Ω—Å–æ–ª—å Firebase.')) return;
    }
    localStorage.removeItem('localBigWins');
    renderBigWins([]);
  });

  // --- CORE GAME FLOW (spin) ---
  function getBetValue(){
    let b = Math.floor(Number(betInput.value) || 0);
    if (b < 1) b = 1;
    if (b > balance) b = balance;
    betInput.value = b;
    return b;
  }

  function getLines(){
    return LINES;
  }

  function animateGrid(arr, winCellsFlat=[]){
    const slots = Array.from(gridEl.children);
    slots.forEach((s,i)=>{
      s.className = 'slot enter';
      s.style.setProperty('--delay', `${(i%COLS)*0.05}s`);
      s.textContent = arr[i] || '‚ùî';
      s.addEventListener('animationend', function onEnd(){
        s.classList.remove('enter'); s.removeEventListener('animationend', onEnd);
        if (winCellsFlat.includes(i)){
          s.classList.add('win'); setTimeout(()=> s.classList.remove('win'), 900);
        }
      });
    });
  }

  function computeLineScores(gridArr){
    const lines = getLines();
    const lineResults = [];
    for (const line of lines){
      const values = line.map(([r,c]) => gridArr[r*COLS + c]);
      const freq = {}; values.forEach(v=> freq[v] = (freq[v]||0) + 1);
      const bestCount = Math.max(...Object.values(freq));
      const bestEmoji = Object.keys(freq).find(k=>freq[k]===bestCount);
      lineResults.push({ values, bestCount, bestEmoji, cells: line });
    }
    return lineResults;
  }

  function payoutFromLines(bet, lineResults){
    let totalMul = 0; let winningCellsFlat = [];
    for (const lr of lineResults){
      const c = lr.bestCount;
      if (LINE_MULT[c] && LINE_MULT[c] > 0) {
        totalMul += LINE_MULT[c];
        lr.cells.forEach(([r,c2]) => winningCellsFlat.push(r*COLS + c2));
      }
    }
    totalMul = Math.min(totalMul, 12);
    const payout = Math.round(bet * totalMul);
    const net = payout - bet;
    return { payout, net, totalMul, winningCellsFlat: [...new Set(winningCellsFlat)] };
  }

  function triggerExplosionFromCells(cellIndices, intensity){
    const slots = Array.from(gridEl.children);
    if (!cellIndices || cellIndices.length === 0){
      const rect = gridEl.getBoundingClientRect();
      triggerExplosion(rect.left + rect.width/2, rect.top + rect.height/2, intensity);
      return;
    }
    // spawn confetti from each winning cell center
    cellIndices.forEach(idx => {
      const s = slots[idx];
      if (!s) return;
      const r = s.getBoundingClientRect();
      Confetti.spawn(r.left + r.width/2, r.top + r.height/2, 24 + intensity*8, 80, 10 + intensity*2);
    });
    // also flash and panel shake
    const rect = gridEl.getBoundingClientRect();
    triggerExplosion(rect.left + rect.width/2, rect.top + rect.height/2, intensity);
  }

  function runSpin(){
    const bet = getBetValue();
    if (bet <= 0){ alert('–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É ‚â• 1'); return; }
    if (bet > balance){ alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤'); return; }

    spinBtn.disabled = true;
    balance -= bet; updateBalanceUI();

    const grid = generateGrid();
    animateGrid(grid);

    const lineResults = computeLineScores(grid);
    const { payout, net, totalMul, winningCellsFlat } = payoutFromLines(bet, lineResults);

    setTimeout(()=> {
      if (payout > 0){ balance += payout; updateBalanceUI(); }

      if (payout > bet){
        scoreText.textContent = `BIG WIN! +${payout - bet} ‚ÇΩ  (x${totalMul.toFixed(2)})`;
      } else if (payout === bet){
        scoreText.textContent = `–ù–∏—á—å—è ‚Äî –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ —Å—Ç–∞–≤–∫–∞ ${payout} ‚ÇΩ`;
      } else {
        scoreText.textContent = `–ü—Ä–æ–∏–≥—Ä—ã—à ${bet - payout} ‚ÇΩ`;
      }
      scoreText.classList.remove('pop'); void scoreText.offsetWidth; scoreText.classList.add('pop');

      const bigLines = lineResults.filter(lr => lr.bestCount >= 3);
      if (bigLines.length > 0){
        // big win detected
        const bigCells = [];
        bigLines.forEach(lr => lr.cells.forEach(([r,c]) => bigCells.push(r*COLS + c)));
        const uniqueBigCells = [...new Set(bigCells)];
        const intensity = Math.min(4, bigLines.length + Math.floor(totalMul/3));
        triggerExplosionFromCells(uniqueBigCells, intensity);

        // prepare big win entry
        const netGain = payout - bet;
        const entry = {
          nick: nickInput.value || 'NewPlayer',
          emoji: lineResults[0].bestEmoji || grid[ Math.floor(Math.random()*grid.length) ],
          amount: netGain,
          bet,
          payout,
          multiplier: totalMul,
          ts: Date.now()
        };
        // push if meets threshold
        if (netGain >= BIG_WIN_NET_MIN || totalMul >= BIG_WIN_MULT_MIN) {
          pushBigWin(entry);
        } else {
          // still add to local recent bigwins list for visibility if netGain positive
          if (netGain > 0) pushBigWin(entry);
        }
      } else if (winningCellsFlat.length > 0 && payout > 0){
        const rect = gridEl.getBoundingClientRect();
        Confetti.spawn(rect.left + rect.width/2, rect.top + rect.height/2, Math.min(120, 6 + Math.floor(payout/2)));
      }

      animateGrid(grid, winningCellsFlat);

      // if big win and offline local storage, render local list
      if (!firebaseDb) loadLocalBigWins();

      spinBtn.disabled = false;
    }, 600);
  }

  // big wins local handling
  function loadLocalBigWins(){
    const arr = JSON.parse(localStorage.getItem('localBigWins') || '[]');
    renderBigWins(arr);
  }
  function renderBigWins(list){
    // Accepts array sorted by ts desc
    bigWinsListEl.innerHTML = '';
    if (!list || list.length === 0){
      bigWinsListEl.innerHTML = '<div style="padding:8px;color:var(--muted)">–ü–æ–∫–∞ –Ω–µ—Ç –±–æ–ª—å—à–∏—Ö –≤—ã–∏–≥—Ä—ã—à–µ–π</div>';
      return;
    }
    list.slice(0,50).forEach(item => {
      const div = document.createElement('div'); div.className = 'bigwin-item';
      const left = document.createElement('div'); left.className = 'bigwin-left';
      const emoji = document.createElement('div'); emoji.className = 'bigwin-emoji'; emoji.textContent = item.emoji || 'üéâ';
      const info = document.createElement('div');
      const nickEl = document.createElement('div'); nickEl.className = 'bigwin-nick'; nickEl.textContent = item.nick || 'Player';
      const time = new Date(item.ts || Date.now());
      const meta = document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='var(--muted)'; meta.textContent = `${time.toLocaleString()} ‚Ä¢ x${(item.multiplier||0).toFixed(2)}`;
      info.appendChild(nickEl); info.appendChild(meta);
      left.appendChild(emoji); left.appendChild(info);
      const right = document.createElement('div'); right.className = 'bigwin-amount'; right.textContent = `+${item.amount} ‚ÇΩ`;
      div.appendChild(left); div.appendChild(right);
      bigWinsListEl.appendChild(div);
    });
  }

  function pushBigWinLocally(entry){
    const arr = JSON.parse(localStorage.getItem('localBigWins') || '[]');
    arr.unshift(entry);
    localStorage.setItem('localBigWins', JSON.stringify(arr.slice(0,200)));
    renderBigWins(arr);
  }

  // push big win to firebase or local
  function pushBigWin(entry){
    if (firebaseDb) {
      try {
        firebaseDb.ref('bigWins').push(entry).catch(()=>{ pushBigWinLocally(entry); });
        return;
      } catch(e){ pushBigWinLocally(entry); }
    } else {
      pushBigWinLocally(entry);
    }
  }

  // clear local big wins (button)
  clearBigWinsBtn.addEventListener('click', ()=>{
    if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –±–æ–ª—å—à–∏—Ö –≤—ã–∏–≥—Ä—ã—à–µ–π?')) {
      localStorage.removeItem('localBigWins');
      renderBigWins([]);
    }
  });

  // load firebase if configured (presence+bigWins)
  loadFirebaseIfConfigured();

  // fallback to local big wins on start
  if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_KEY") {
    loadLocalBigWins();
  }

  // simple daily dice (kept)
  const dailyRollBtn = document.getElementById('dailyRollBtn');
  const dailyInfo = document.getElementById('dailyInfo');
  function canUseDaily(){ const now=Date.now(); const day=24*60*60*1000; return (now - lastDailyRoll) >= day; }
  function formatMs(ms){ const s=Math.floor(ms/1000); const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); const ss = s%60; return `${h}—á ${m}–º ${ss}—Å`; }
  function updateDailyButton(){ if (!dailyInfo || !dailyRollBtn) return; const now=Date.now(); const day=24*60*60*1000; if ((now - lastDailyRoll) >= day) { dailyRollBtn.disabled=false; dailyInfo.textContent = '–ö—É–±–∏–∫ –¥–æ—Å—Ç—É–ø–µ–Ω ‚Äî –º–∏–Ω–∏–º—É–º 100 ‚ÇΩ'; } else { dailyRollBtn.disabled = true; dailyInfo.textContent = '–û—Å—Ç–∞–ª–æ—Å—å: ' + formatMs(Math.max(0, day - (now - lastDailyRoll))); } }
  if (dailyRollBtn) {
    dailyRollBtn.addEventListener('click', ()=>{
      if (!canUseDaily()) { updateDailyButton(); return; }
      const roll = Math.floor(Math.random()*6) + 1;
      const reward = 100 * roll;
      balance += reward; updateBalanceUI();
      lastDailyRoll = Date.now(); try { localStorage.setItem('lastDailyRoll', String(lastDailyRoll)); } catch {}
      dailyInfo.textContent = `–í—ã–ø–∞–ª–æ ${roll} ‚Äî +${reward} ‚ÇΩ`;
      const rect = gridEl.getBoundingClientRect();
      Confetti.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 140, 220, 18);
      if (flashEl) { flashEl.style.opacity = '1'; setTimeout(()=> flashEl.style.opacity = '0', 300); }
      // register as big win if large enough
      if (reward >= BIG_WIN_NET_MIN) {
        const entry = { nick: nickInput.value || 'NewPlayer', emoji: 'üé≤', amount: reward, bet:0, payout:reward, multiplier: (reward/100), ts: Date.now() };
        pushBigWin(entry);
      }
      setTimeout(()=> updateDailyButton(), 1000);
    });
    setInterval(updateDailyButton, 1000);
    updateDailyButton();
  }

  // UI bindings
  spinBtn.addEventListener('click', runSpin);
  startBtn.addEventListener('click', ()=> alert('–ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞. –ù–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ç–æ–∫"'));
  resetBtn.addEventListener('click', ()=> { if (confirm('–°–±—Ä–æ—Å–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ?')) { localStorage.clear(); location.reload(); }});
  minBetBtn.addEventListener('click', ()=> betInput.value = 1);
  halfBetBtn.addEventListener('click', ()=> betInput.value = Math.max(1, Math.floor(balance/2)));
  maxBetBtn.addEventListener('click', ()=> betInput.value = balance);
  nickInput.addEventListener('input', ()=> { nick = nickInput.value || 'NewPlayer'; try{ localStorage.setItem('nick', nick); }catch{} });
  dynSelect.addEventListener('change', ()=> { dyn = dynSelect.value; try{ localStorage.setItem('dyn', dyn); }catch{} });

  // seed and initial UI
  (function seed(){ const base = Array.from({length:SLOT_COUNT}, (_,i) => EMOJI_POOL[(i*2)%EMOJI_POOL.length]); animateGrid(base); scoreText.textContent = '–ù–∞–∂–º–∏—Ç–µ ¬´–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ç–æ–∫¬ª'; })();
  updateBalanceUI(); updateVaultUI();
  // if no firebase, ensure online counter simulated
  if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_KEY") {
    // simple simulation: small random walk
    let simCount = Math.max(1, Math.floor(Math.random()*12)+3);
    onlineEl.textContent = simCount;
    setInterval(()=> {
      simCount += (Math.random() < 0.5 ? -1 : 1) * (Math.random() < 0.75 ? 1 : 2);
      if (simCount < 1) simCount = 1;
      onlineEl.textContent = simCount;
    }, 3500);
  }

  </script>
</body>
</html>
